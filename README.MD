Java 디자인 패턴 연습
=
## 1. 환경 : jdk 11
## 2. 빌드 툴 : Gradle 5.2.1
## 3. 목적
### + 각종 패턴 학습 및 이해
### + 제대로 된 Git 사용 방법 학습 및 MarkDown 작성방법 학습
### + Gradle 사용 학습
## 4. 학습방법
### * 패턴에 대해서 모르는게 있을 경우 일단, 따라하던 예제를 그대로 작성해두고, Issues에 개인 메모를 남겨놓고, 완전히 이해한다음에 close하기
### * "완전히" 이해가 끝난 패턴은 Wiki에 따로 정리해보기
## 5. 인코딩은 UTF-8로 통일하기

<hr />

#### 전략 패턴이란
> 각 객체 내에서 동일한 역할을 맡은 메소드들을 하나의 알고리즘 군으로 캡슐화하고(여러 알고리즘 군이 생성될 수 있음), 클라이언트에서 그 알고리즘 군의 상세 객체를 생성해서 유연하게 적용한다.

<ul>
    <li>전략 패턴에서는 RPG 게임의 보스 몬스터를 클래스로 구현하였다.<br />원래는 사용자의 정보도 넘겨받아서 그 수치에 따라 주는 피해나 상태이상과 같은 상태도 관리하려고 하였으나 다른 패턴을 학습하고 나서 적용해볼 생각이다. <br />다른 클래스와의 상호 작용(캐릭터에 의한 공격)등은 구현하지 않는다.</li>
    <li>보스몬스터는 브레스 공격, 비행 공격, 육지 이동, 비행 이동, 회피 등의 행동을 할 수 있다.</li>
    <li>보스 몬스터 중에 착한 보스는 공격, 이동 없이 회피만 가능하다.</li>
    <li>반대로 육지 보스의 경우 비행 이동 및 비행회피는 불가능하고, 비행 보스는 육지 이동 및 육지 회피는 불가능하다.</li>
    <ul>
        <li>물론, 공격을 더 세분화하여 일반 공격 및 특수 공격(돌진, 브레스, 잡기, 장판, 비행 공격 등)이 있으나 아직까지는 구현하지 않는다(언젠가는 해볼 것이라서 enum으로 선언은 해놓았다).</li>
        <li>각 보스몬스터가 할 수 있는 특수 공격이 정해져있다. <br />예를 들어, A라는 몬스터는 모든 특수 공격을 할 수 있고, B라는 몬스터는 비행공격을 할 수 없고, C라는 몬스터는 브레스와 장판 공격만 할 수 있다고 가정해볼 수 있다. <br />이것 또한 단순한 전략 패턴에서는 쓰지 않을 것이다. </li>
    </ul>
    <li>before에서는 공격, 이동, 회피 등을 알고리즘 군으로 캡슐화하지 않고, 필요에 따라(각 객체가 하지 않는 행위를 할 경우) 각 클래스마다 메소드를 재정의 하였다.</li>
    <li>before에서 발이 없는데 땅으로 움직이고, 날개도 없는데 날아다니면 말이 되지 않는다. 하지만, 별다른 수정(가장 쉽게하는 오버라이드)을 하지 않으면 그런 일이 실제로 발생한다. 그리고 그냥 회피만 할 수 있는 착한 보스가 공격을 하면, 혼란스러울 것이다.</li>
    <li>after에서는 공격, 이동, 회피를 추상화 하여 이를 구현하는 상세 클래스를 정의한다.</li>
</ul>

<hr />

#### 옵저버 패턴이란
> 특정 클래스 A(주제 클래스)를 인스턴스화한 객체의 값(또는 상태)이(가) 변하게되었을 때, 이 특정 객체의 값(또는 상태)에 따라 대응하는 객체(Observer)들의 값 또는 상태도 변경할 수 있도록 설계된 패턴. 더는 주제 객체의 값에 따라 자신의 상태를 좌지우지 하고 싶지 않을 경우에는 주제 객체에 자신을 관리하지 말라는 메세지를 보낼 수도 있음.
>> 주제에서 직접 Observer들에게 전달(push)해 줄 수도 있고, Observer에서 직접 주제의 상태를 가져올 수(pull)도 있음.
>>> 전략 패턴과는 다르게 패키지를 두 개로 나누지 않고, 곧바로 구현해볼 생각. 딱히 이상하게 코딩하기 쉽지 않을 것 같음.
>>> 자바 자체에서 제공하는 API가 존재하며, 이 API는 사용하지 않을 생각.
<ul>
    <li>주제 클래스 : 회원이 존재하는 사이트(모든 회원은 회원정보 제공 찬성했다고 가정)</li>
    <li>옵저버 클래스 : 주제 사이트(주제 클래스)에서 회원 정보를 넘겨받기로 협약을 맺은 업체(각 업체별로 해당 정보 저장 포맷이 다름)</li>
    <li>제공받는 데이터 : 현재 주제 사이트에 가입되어 있는 회원의 정보</li>
</ul>

<hr />

#### 장식자(Decorator) 패턴
> 특정 객체 A를 생성하는데 있어서, 이 A의 "기능을 확장"할 때, 객체 A를 상속을 하지 않고, 데코레이터 클래스들을 사용하여 "기능을 확장"시키는 패턴. 
>> 데코레이터 클래스에서는 특정 객체 A를 상속받으면서(구현하면서), 데코레이터 안에 A를 구성하여 이 객체의 상태를 변경해 나간다.
>> 데코레이터 패턴은 "하나의" 중심 객체에 계속해서 무작정 상태를 덧붙인다고 보면 된다.
>> 자바스크립트의 메소드 체이닝
>> 자바에서 데코레이터 패턴을 사용하는 예제는 java.io 패키지의 InputStream 계통을 살펴보면 된다.
>>> 일반적으로 데코레이터 패턴은 단독으로 사용되지 않고, 팩토리나 빌더 패턴같은 생성 패턴과 함께 쓰인다.
>>>> 데코레이터 패턴을 적용하지 않고, 이 치킨 세트를 구현한다고 생각하면, 치킨에 각 데코레이터가 적용된 모든 경우의 수를 다 따져서 클래스를 생성해야 한다(말이 필요없을 정도로 클래스의 갯수가 증가한다, 이 상태에서 치킨의 가격이나 기타 데코레이터의 가격이 증가한다고 생각하면 그 클래스를 다 수정해야 한다).

<ul>
    <li>하나의 치킨 세트를 구현해볼 것이다.</li>
    <li>계산을 할 치킨 세트를 루트로 두고, 이 치킨세트의 기본은 치킨(양념, 프라이드, 순살 프라이드, 순살 양념 : 일반적으로 프라이드에 양념을 더하면 그게 양념치킨이겠지만, 양념을 데코레이터로 만들게 되면, 치킨은 한 마리인데, 양념은 계속 추가할 수 있는 상황이 올 수도 있다. 그렇게 되면 가격 책정이 이상해진다. 이 모호함을 피하고자 이에 대한 디자인은 하지 않았다)이다. 여기에 소스, 무, 콜라, 사이다 등을 추가할 수도 있다(하나 이상).</li>
    <li>이 치킨 세트에는 치킨이 여러 마리 올 수도 있다.</li>
    <li>주문 내역을 표시할 때 LinkedHashMap을 사용하여 주문순서와 주문 내역을 저장하는 소스가 있다.</li>
</ul>

#### 팩토리(Factory) 패턴
> 팩토리(Factory)가 들어가는 패턴은 두 개이며, 두 개의 패턴 모두 공통적으로 구체 객체를 생성하는 부분을 캡슐화하였다.
>> 팩토리 메소드 패턴은 구체 제품 클래스의 생성을 구체 팩토리에서만 전담하는 형태이고, 추상 팩토리 패턴은 원재료 군을 생산하기 위한 팩토리를 따로 사용한다는 것이 다르다. 
>> 추상 팩토리 패턴은 구성을 통해 원재료 군을 생성하는 방법을 제공받는다.
>> 추상 팩토리 패턴에서 구체 제품을 생성하기 위해 팩토리 메소드 패턴을 사용할 수도 있다.
>> 추상 팩토리 패턴은 다양한 제품군을 다루지만, 만약 원재료 군이 변화하게 되면, 인터페이스에 메소드를 추가해줘야 한다(소스 코드를 피할 수 없다).
>> 팩토리 메소드에서는 하나의 제품이 등록되면 구체 제품 클래스를 생성하고, 구체 팩토리에 이를 작성해주면 되지만, 뚜렷한 하나의 객체만을 생성할 수 있다.

##### 팩토리 메소드(Factory Method) 패턴
> 객체 생성을 위한 인터페이스(팩토리)를 지정하고, 어떤 구체 클래스의 객체가 생성될 것인가는 이 팩토리의 서브 클래스(구체 팩토리)에서만 담당하는 패턴(new 구상클래스() 문이 구체 팩토리에만 있다). 구체 클래스 생성의 전권은 구체 팩토리에만 있다. 

##### 추상 팩토리(Abstract Factory) 패턴
> 추상화된 팩토리를 구현하여 객체를 구성하는 원재료군을 생성하는 방법을 별도로 분리해놓은 구체 팩토리를 생성하고, 클라이언트에서 이 구체 팩토리의 변경만을 통해 어떤 원재료군을 생성할 것인지 정하는 패턴. 이 원재료를 사용하여, 어떻게 구체 객체를 생성할 것인가는 각 구체 제품 클래스에서 정해주면 된다.

<ul>
    <li>팩토리 패턴(들)에서는 유명 치킨 프랜차이즈 별로 치킨 객체를 생성할 것이다. 이 브랜드에는 너네, 볶네, 호돌이가 있다.</li>
    <li>너네, 볶네, 호돌이 치킨집의 요리사들이 하나의 점포에 뭉쳐있다.</li>
    <li>이 점포에서는 위 3업체의 치킨을 모두 한 곳에서 주문을 할 수 있다.</li>
    <li>치킨이 만들어지고 나면, 포장은 이 점포 자체에서 해준다.</li>
    <li>before, method, abstractf 패키지 이렇게 세 가지를 둘 것이다.</li>
    <li>before에서는 팩토리 패턴을 적용하지 않을 것이며, method에서는 팩토리 메소드 패턴을 적용, abstractf에서는 추상 팩토리 패턴을 적용할 것이다.</li>
    <li>치킨을 주문받고, 치킨 객체를 생성하는 과정까지 해 볼 것이다.</li>
</ul>
