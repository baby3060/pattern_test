Java 디자인 패턴 연습
=
## 1. 환경 : jdk 11
## 2. 빌드 툴 : Gradle 5.2.1
## 3. 목적
### + 각종 패턴 학습 및 이해
### + 제대로 된 Git 사용 방법 학습 및 MarkDown 작성방법 학습
### + Gradle 사용 학습
## 4. 학습방법
### * 패턴에 대해서 모르는게 있을 경우 일단, 따라하던 예제를 그대로 작성해두고, Issues에 개인 메모를 남겨놓고, 완전히 이해한다음에 close하기
### * "완전히" 이해가 끝난 패턴은 Wiki에 따로 정리해보기
## 5. 인코딩은 UTF-8로 통일하기

<hr />

#### 전략 패턴이란
> 각 객체 내에서 동일한 역할을 맡은 메소드들을 하나의 알고리즘 군으로 캡슐화하고(여러 알고리즘 군이 생성될 수 있음), 클라이언트에서 그 알고리즘 군의 상세 객체를 생성해서 유연하게 적용한다.

<ul>
    <li>전략 패턴에서는 RPG 게임의 보스 몬스터를 클래스로 구현하였다.<br />원래는 사용자의 정보도 넘겨받아서 그 수치에 따라 주는 피해나 상태이상과 같은 상태도 관리하려고 하였으나 다른 패턴을 학습하고 나서 적용해볼 생각이다. <br />다른 클래스와의 상호 작용(캐릭터에 의한 공격)등은 구현하지 않는다.</li>
    <li>보스몬스터는 브레스 공격, 비행 공격, 육지 이동, 비행 이동, 회피 등의 행동을 할 수 있다.</li>
    <li>보스 몬스터 중에 착한 보스는 공격, 이동 없이 회피만 가능하다.</li>
    <li>반대로 육지 보스의 경우 비행 이동 및 비행회피는 불가능하고, 비행 보스는 육지 이동 및 육지 회피는 불가능하다.</li>
    <ul>
        <li>물론, 공격을 더 세분화하여 일반 공격 및 특수 공격(돌진, 브레스, 잡기, 장판, 비행 공격 등)이 있으나 아직까지는 구현하지 않는다(언젠가는 해볼 것이라서 enum으로 선언은 해놓았다).</li>
        <li>각 보스몬스터가 할 수 있는 특수 공격이 정해져있다. <br />예를 들어, A라는 몬스터는 모든 특수 공격을 할 수 있고, B라는 몬스터는 비행공격을 할 수 없고, C라는 몬스터는 브레스와 장판 공격만 할 수 있다고 가정해볼 수 있다. <br />이것 또한 단순한 전략 패턴에서는 쓰지 않을 것이다. </li>
    </ul>
    <li>before에서는 공격, 이동, 회피 등을 알고리즘 군으로 캡슐화하지 않고, 필요에 따라(각 객체가 하지 않는 행위를 할 경우) 각 클래스마다 메소드를 재정의 하였다.</li>
    <li>before에서 발이 없는데 땅으로 움직이고, 날개도 없는데 날아다니면 말이 되지 않는다. 하지만, 별다른 수정(가장 쉽게하는 오버라이드)을 하지 않으면 그런 일이 실제로 발생한다. 그리고 그냥 회피만 할 수 있는 착한 보스가 공격을 하면, 혼란스러울 것이다.</li>
    <li>after에서는 공격, 이동, 회피를 추상화 하여 이를 구현하는 상세 클래스를 정의한다.</li>
</ul>

<hr />

#### 옵저버 패턴이란
> 특정 클래스 A(주제 클래스)를 인스턴스화한 객체의 값(또는 상태)이(가) 변하게되었을 때, 이 특정 객체의 값(또는 상태)에 따라 대응하는 객체(Observer)들의 값 또는 상태도 변경할 수 있도록 설계된 패턴. 더는 주제 객체의 값에 따라 자신의 상태를 좌지우지 하고 싶지 않을 경우에는 주제 객체에 자신을 관리하지 말라는 메세지를 보낼 수도 있음.
>> 주제에서 직접 Observer들에게 전달(push)해 줄 수도 있고, Observer에서 직접 주제의 상태를 가져올 수(pull)도 있음.
>> 전략 패턴과는 다르게 패키지를 두 개로 나누지 않고, 곧바로 구현해볼 생각. 딱히 이상하게 코딩하기 쉽지 않을 것 같음.
>>> 자바 자체에서 제공하는 API가 존재하며, 이 API는 사용하지 않을 생각.